/* 
* The polynome library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "complexPolynome.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur par défaut
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome::complexPolynome(void)
	: polynomeBase<complex>()
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de copie de la classe complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome::complexPolynome(const complexPolynome & poly) 
	: polynomeBase<complex>()
{
	copy(poly);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de complexPolynome constant de valeur value.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome::complexPolynome(const complex & value) 
	: polynomeBase<complex>()
{
	clear();
	setData(0,value);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructeur de la classe complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome::~complexPolynome(void)
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::centerMonomeMultiply(const complex & root) const
{
	complexPolynome shiftingcomplexPolynome , shiftedcomplexPolynome;

	shiftingcomplexPolynome.clear();
	shiftingcomplexPolynome.setData(0,-root);
	shiftingcomplexPolynome.setData(1,1);

	shiftedcomplexPolynome = *this;
	shiftedcomplexPolynome *= shiftingcomplexPolynome;

	return shiftedcomplexPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine  avec un ordre degree au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::centerMonomeMultiply(const complex & root , const int & degree) const
{
	int i;
	complexPolynome shiftedcomplexPolynome(*this);

	for(i=0 ; i < degree ; i++) {
		shiftedcomplexPolynome = shiftedcomplexPolynome.centerMonomeMultiply(root);
	}

	return shiftedcomplexPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::derivate(void) const
{
	complexPolynome deriv;
	int i ;

	deriv.clear();

	for(i= begin() ; i != end() ; i = next(i))  {
		if(i > 0) {
			deriv.setData(i-1 , i * getData(i));			
		}
	}

	return deriv;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour connaitre la forme des fonctions de bases.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const string complexPolynome::getBaseString(const int & i) const
{
	return monome2string("x" , 0 , i);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::monomeMultiply(const int & degre) const
{
	assert( degre >=0);

	if(degre == 0) 
		return *this;

	complexPolynome p;
	int i;

	p.clear();

	for(i = begin() ; i != end() ; i= next(i)) {
		p.setData(i+degre , getData(i));
	}

	return p;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur d'affectation
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator=(const complexPolynome & p)
{
	copy(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::operator+ (const complexPolynome & p) const
{
	complexPolynome tmp;
	tmp.add(*this,p);
	return tmp;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator+= (const complexPolynome & p)
{
	add(p);
	return *this;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::operator* (const complexPolynome & p) const
{
	complexPolynome tmp;
	tmp.multiply(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator*= (const complexPolynome & p)
{
	multiply(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un complexPolynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::operator* (const complex & scalar) const
{
	complexPolynome tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire d'un complexPolynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator*= (const complex & scalar)
{
	multiply(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un scalaire et d'un complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome operator* (const complex & scalar , const complexPolynome & p)
{
	return p*scalar;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::operator- (const complexPolynome & p) const
{
	complexPolynome tmp;
	tmp.soustract(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator-= (const complexPolynome & p)
{
	soustract(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division d'un complexPolynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::operator/ (const complex & scalar) const
{
	assert(scalar != 0);
	complexPolynome tmp;
	tmp.divide(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division unaire d'un complexPolynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome & complexPolynome::operator /=(const complex & scalar)
{
	assert(scalar != 0);
	divide(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour faire un changement de variable linéaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome complexPolynome::scale(const complex & scalar) 
{
	int i , degree;
	complex scalingFactor;	

	complexPolynome scaledcomplexPolynome;

	scaledcomplexPolynome.clear();
	
	i=0;
	scalingFactor =1;

	for(degree=begin() ; degree != end() ; degree = next(i)) {

		for( ; i < degree ; i++) {
			scalingFactor *= scalar;
		}

		scaledcomplexPolynome.setData(degree , scalingFactor * getData(degree));
	}
	
	return scaledcomplexPolynome;
}
