/* 
* The polynome library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "polynome3D.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur par défaut
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D::polynome3D(void)
	: polynomeBase3D<double>()
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de copie de la classe polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D::polynome3D(const polynome3D & poly) 
	: polynomeBase3D<double>()
{
	copy(poly);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de polynome constant de valeur value.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D::polynome3D(const double & value) 
	: polynomeBase3D<double>()
{
	setPolynomeCoefficients(value);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructeur de la classe polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D::~polynome3D(void)
{
	clear();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiply(const double & root , const int & dimension) const
{
	assert(dimension >= 0);
	assert(dimension < 3);

	polynome3D shiftingPolynome , shiftedPolynome;
	ipoint<3> i(0);

	i[dimension] = 1;
	shiftingPolynome.clear();
	shiftingPolynome.setData(0,-root);
	shiftingPolynome.setData(i,1);

	shiftedPolynome = *this;
	shiftedPolynome *= shiftingPolynome;

	return shiftedPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine  avec un ordre degree au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiply(const double & root , const int & dimension , const int & degree) const
{
	assert(dimension >= 0);
	assert(dimension < 3);
	assert(degree >= 0);

	int i;
	polynome3D shiftedPolynome(*this);

	for(i=0 ; i < degree ; i++) {
		shiftedPolynome = shiftedPolynome.centerMonomeMultiply(root,dimension);
	}

	return shiftedPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine  avec un ordre degree au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiply(const dpoint<3> & root , const ipoint<3> & degree) const
{
	assert(degree[0] >=0);
	assert(degree[1] >=0);
	assert(degree[2] >=0);

	polynome3D shiftedPolynome(*this);

	for(int dim = 0; dim < 3 ; dim++) {
		shiftedPolynome = shiftedPolynome.centerMonomeMultiply(root[dim],dim,degree[dim]);	
	}
	
	return shiftedPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui multiplie le polynome par (x-root)^degree.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiplyX(const double & root , const int & degree) const
{
	assert(degree >= 0);
	return centerMonomeMultiply(root,0,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui multiplie le polynome par (y-root)^degree.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiplyY(const double & root , const int & degree) const
{
	assert(degree >= 0);
	return centerMonomeMultiply(root,1,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui multiplie le polynome par (z-root)^degree.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::centerMonomeMultiplyZ(const double & root , const int & degree) const
{
	assert(degree >= 0);
	return centerMonomeMultiply(root,2,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le polynome dérivé.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::derivate(const int & dimension) const
{
	assert(dimension >=0);
	assert(dimension < 3);

	ipoint<3> i;
	double value;
	polynome3D deriv;

	deriv.clear();

	for(i = begin() ; i != end() ; i = next(i)) {
		if(i[dimension] != 0) {
			value = getData(i) * i[dimension];
			i[dimension]--;
			deriv.setData(i,value);
			i[dimension]++;
		}
	}	

	return deriv;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le polynome dérivé.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::derivate(const ipoint<3> & derivationDegree) const
{
	int dimension , i;
	polynome3D tmp(*this);

	for(dimension=0 ; dimension < 3 ; dimension++) {
		for( i = 0 ; i < derivationDegree[dimension] ; i++) {
			tmp = tmp.derivate(dimension);
		} 
	}

	return tmp;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le polynome dérivé par rappport à la première variable.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::derivateX(void) const
{
	return derivate(0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le polynome dérivé par rappport à la seconde variable.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::derivateY(void) const
{
	return derivate(1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le polynome dérivé par rappport à la troisième.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::derivateZ(void) const
{
	return derivate(2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method EVAL
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double polynome3D::eval(const dpoint<3> & x) const
{
	double value=0;
	ipoint<3> degree;
	
	for(degree=begin() ; degree != end() ; degree = next(degree)) {
	
		value += getData(degree) * pow(x[0],degree[0]) * pow(x[1],degree[1]) * pow(x[2],degree[2]);
	}
	
	return value;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour connaitre la forme des fonctions de bases.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const string polynome3D::getBaseString(const ipoint<3> & i) const
{
	return monome3D2string(i);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::monomeMultiply(const int & dimension , const int & degree) const
{
	assert(dimension >= 0);
	assert(dimension < 3);

	ipoint<3> i(0);
	i[dimension] = degree;
	return monomeMultiply(i);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::monomeMultiplyX(const int & degree) const
{
	return monomeMultiply(0,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::monomeMultiplyY(const int & degree) const
{
	return monomeMultiply(1,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::monomeMultiplyZ(const int & degree) const
{
	return monomeMultiply(2,degree);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::monomeMultiply(const ipoint<3> & degree) const
{
	assert( degree[0] >=0);
	assert( degree[1] >=0);
	assert( degree[2] >=0);

	if(degree == ipoint<3>(0)) 
		return *this;

	polynome3D p;
	ipoint<3> i;

	p.clear();

	for(i = begin() ; i != end() ; i= next(i)) {
		p.setData(i+degree , getData(i));
	}

	return p;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur d'affectation
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator=(const polynome3D & p)
{
	copy(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::operator+ (const polynome3D & p) const
{
	polynome3D tmp;
	tmp.add(*this,p);
	return tmp;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition unaire de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator+= (const polynome3D & p)
{
	add(p);
	return *this;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::operator* (const polynome3D & p) const
{
	polynome3D tmp;
	tmp.multiply(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator*= (const polynome3D & p)
{
	multiply(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un polynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::operator* (const double & scalar) const
{
	polynome3D tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire d'un polynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator*= (const double & scalar)
{
	multiply(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un scalaire et d'un polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D operator* (const double & scalar , const polynome3D & p)
{
	return p*scalar;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::operator- (const polynome3D & p) const
{
	polynome3D tmp;
	tmp.soustract(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction unaire de deux polynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator-= (const polynome3D & p)
{
	soustract(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division d'un polynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::operator/ (const double & scalar) const
{
	assert(scalar != 0);
	polynome3D tmp;
	tmp.divide(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division unaire d'un polynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D & polynome3D::operator /=(const double & scalar)
{
	assert(scalar != 0);
	divide(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour faire un changement de variable linéaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
polynome3D polynome3D::scale(const dpoint<3> & scalar) 
{
	int dim;
	ipoint<3> i , degree;
	dpoint<3> scalingFactor;	

	polynome3D scaledPolynome;

	scaledPolynome.clear();
	
	i.setDatas(0);
	scalingFactor.setDatas(1);

	for(degree=begin() ; degree != end() ; degree = next(i)) {

		for(dim = 0 ; dim < 3 ; dim++) {
			
			if(i[dim] > degree[dim]) {
				scalingFactor[dim] = 1;
				i[dim] = 0;
			}
			
			for( ; i[dim] < degree[dim] ; i[dim]++) {
				scalingFactor[dim] *= scalar[dim];
			}
		}

		scaledPolynome.setData(degree , scalingFactor[0] * scalingFactor[1] * scalingFactor[2] * getData(degree));
	}
	
	return scaledPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour donner au polynome une valeur constante.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void polynome3D::setPolynomeCoefficients(const double & value)
{
	clear();
	setData(0,0,0,value);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour recopier la valeur d'un polynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void polynome3D::setPolynomeCoefficients(const polynome3D & poly)
{
	copy(poly);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode Construire le polynome 3D comme un produit de polynome mono dimensionel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void polynome3D::setPolynomeCoefficients(const polynome & polyX , const polynome & polyY , const polynome & polyZ)
{
	clear();
	int i , j , k;
	double dataX , dataY , dataZ;

	for(i = polyX.begin() ; i != polyX.end() ; i = polyX.next(i)) {
		dataX = polyX.getData(i);
		for(j = polyY.begin() ; j != polyY.end() ; j = polyY.next(j)) {
			dataY = polyY.getData(j);
			for(k = polyZ.begin() ; k != polyZ.end() ; k = polyZ.next(k)) {
				dataZ = polyZ.getData(k);
				setData(i,j,k,dataX * dataY * dataZ);
			}
		}
	}

}
