/* 
* The polynome library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "complexPolynome3D.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur par défaut
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D::complexPolynome3D(void)
	: polynomeBase3D<complex>()
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de copie de la classe complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D::complexPolynome3D(const complexPolynome3D & poly) 
	: polynomeBase3D<complex>()
{
	copy(poly);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de complexPolynome constant de valeur value.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D::complexPolynome3D(const complex & value) 
	: polynomeBase3D<complex>()
{
	clear();
	setData(0,0,0,value);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructeur de la classe complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D::~complexPolynome3D(void)
{
	clear();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::centerMonomeMultiply(const complex & root , const int & dimension) const
{
	assert(dimension >= 0);
	assert(dimension < 3);

	complexPolynome3D shiftingcomplexPolynome , shiftedcomplexPolynome;
	ipoint<3> i(0);

	i[dimension] = 1;
	shiftingcomplexPolynome.clear();
	shiftingcomplexPolynome.setData(0,-root);
	shiftingcomplexPolynome.setData(i,1);

	shiftedcomplexPolynome = *this;
	shiftedcomplexPolynome *= shiftingcomplexPolynome;

	return shiftedcomplexPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui ajoute root comme racine  avec un ordre degree au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::centerMonomeMultiply(const complex & root , const int & dimension , const int & degree) const
{
	assert(dimension >= 0);
	assert(dimension < 2);

	int i;
	complexPolynome3D shiftedcomplexPolynome(*this);

	for(i=0 ; i < degree ; i++) {
		shiftedcomplexPolynome = shiftedcomplexPolynome.centerMonomeMultiply(root,dimension);
	}

	return shiftedcomplexPolynome;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::derivate(const int & dimension) const
{
	assert(dimension >=0);
	assert(dimension < 3);

	ipoint<3> i;
	complex value;
	complexPolynome3D deriv;

	deriv.clear();

	for(i = begin() ; i != end() ; i = next(i)) {
		if(i[dimension] != 0) {
			value = getData(i) * i[dimension];
			i[dimension]--;
			deriv.setData(i,value);
			i[dimension]++;
		}
	}	

	return deriv;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::derivate(const ipoint<3> & derivationDegree) const
{
	int dimension , i;
	complexPolynome3D tmp(*this);

	for(dimension=0 ; dimension < 3 ; dimension++) {
		for( i = 0 ; i < derivationDegree[dimension] ; i++) {
			tmp = tmp.derivate(dimension);
		} 
	}

	return tmp;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé par rappport à la première variable.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::derivateX(void) const
{
	return derivate(0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé par rappport à la seconde variable.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::derivateY(void) const
{
	return derivate(1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui calcule le complexPolynome dérivé par rappport à la troisième.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::derivateZ(void) const
{
	return derivate(2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour connaitre la forme des fonctions de bases.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const string complexPolynome3D::getBaseString(const ipoint<3> & i) const
{
	return monome3D2string(i);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode qui permet d'ajouter un zéro au complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::monomeMultiply(const ipoint<3> & degree) const
{
	assert( degree[0] >=0);
	assert( degree[1] >=0);
	assert( degree[2] >=0);

	if(degree == ipoint<3>(0)) 
		return *this;

	complexPolynome3D p;
	ipoint<3> i;

	p.clear();

	for(i = begin() ; i != end() ; i= next(i)) {
		p.setData(i+degree , getData(i));
	}

	return p;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur d'affectation
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator=(const complexPolynome3D & p)
{
	copy(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::operator+ (const complexPolynome3D & p) const
{
	complexPolynome3D tmp;
	tmp.add(*this,p);
	return tmp;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire l'addition unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator+= (const complexPolynome3D & p)
{
	add(p);
	return *this;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::operator* (const complexPolynome3D & p) const
{
	complexPolynome3D tmp;
	tmp.multiply(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator*= (const complexPolynome3D & p)
{
	multiply(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un complexPolynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::operator* (const complex & scalar) const
{
	complexPolynome3D tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication unaire d'un complexPolynome et d'un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator*= (const complex & scalar)
{
	multiply(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la multiplication d'un scalaire et d'un complexPolynome.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D operator* (const complex & scalar , const complexPolynome3D & p)
{
	return p*scalar;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::operator- (const complexPolynome3D & p) const
{
	complexPolynome3D tmp;
	tmp.soustract(*this,p);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur pour faire la soustraction unaire de deux complexPolynomes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator-= (const complexPolynome3D & p)
{
	soustract(p);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division d'un complexPolynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D complexPolynome3D::operator/ (const complex & scalar) const
{
	assert(scalar != 0);
	complexPolynome3D tmp;
	tmp.divide(*this,scalar);
	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour la division unaire d'un complexPolynome par un scalaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complexPolynome3D & complexPolynome3D::operator /=(const complex & scalar)
{
	assert(scalar != 0);
	divide(scalar);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour faire un changement de variable linéaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//complexPolynome3D complexPolynome3D::scale(const dpoint<3> & scalar) 
//{
//	int dim;
//	ipoint<3> i , degree;
//	dpoint<3> scalingFactor;	
//
//	complexPolynome3D scaledcomplexPolynome;
//
//	scaledcomplexPolynome.clear();
//	
//	i.setDatas(0);
//	scalingFactor.setDatas(1);
//
//	for(degree=begin() ; degree != end() ; degree = next(i)) {
//
//		for(dim = 0 ; dim < 3 ; dim++) {
//			
//			if(i[dim] > degree[dim]) {
//				scalingFactor[dim] = 1;
//				i[dim] = 0;
//			}
//			
//			for( ; i[dim] < degree[dim] ; i[dim]++) {
//				scalingFactor[dim] *= scalar[dim];
//			}
//		}
//
//		scaledcomplexPolynome.setData(degree , scalingFactor[0] * scalingFactor[1] * scalingFactor[2] * getData(degree));
//	}
//	
//	return scaledcomplexPolynome;
//}
