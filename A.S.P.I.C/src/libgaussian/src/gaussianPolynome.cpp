/* 
* The gaussian library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "gaussianPolynome.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome::gaussianPolynome(void)
	: gaussian()
{
	;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur avec une gaussienne :
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome::gaussianPolynome(const gaussian & g)
	: gaussian(g)
{
	;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de copie :
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome::gaussianPolynome(const gaussianPolynome & gp)
{
	copy(gp);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructeur.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome::~gaussianPolynome(void)
{
	;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode qui multiplie la gaussienne avec un monone centrÃ©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussianPolynome::centerMonomeMultiply(const double & root) const
{
	gaussianPolynome shiftedPolynome(((const gaussian &)*this));
	shiftedPolynome.setPolynomeCoefficients(polynome::centerMonomeMultiply(root - getCenter()));
	return shiftedPolynome;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode qui multiplie la gaussienne avec un monone centrÃ©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussianPolynome::centerMonomeMultiply(const double & root , const int & degree) const
{
	assert (degree >= 0);
	int i;
	gaussianPolynome shiftedPolynome(*this);
	for(i=0 ; i < degree ; i++) {
		shiftedPolynome = shiftedPolynome.centerMonomeMultiply(root);
	}
	return shiftedPolynome;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour mettre le polynome Ã  0.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::clearPolynome(void)
{
	polynome::clear();
}

/////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode qui change le centre de la gaussienne.
// Cette mÃ©thode permet de changer le centre de la gaussienne, mais laisse le polynome
// qui va avec celle ci intacte en l'exprimant sur la base des (x-center)^m.
/////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::changeCenter(const double & newCenter)
{
	polynome p(0) , basePolynome(1) , shiftPolynome;
	
	if(newCenter == getCenter()) {
		return;
	}
	
	for(int i =begin() ; i!= end() ; i=next(i)) {
		basePolynome = basePolynome.centerMonomeMultiply(getCenter()-newCenter,i-basePolynome.getDegree());
		p+= (getPolynomeCoefficient(i) * basePolynome);
	}

	setCenter(newCenter);
	setPolynomeCoefficients(p);
}

/////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode de copie du polynome gaussien :
// - On "caste" l'argument en polynome de base et on copie la partie polynomiale.
// - On "caste" l'argument en gaussienne et on copie la gaussienne.
//////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::copy(const gaussianPolynome & gp)
{
	polynome::copy(gp);
	gaussian::copy(gp);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour dÃ©river un polynome gaussien.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussianPolynome::derivate(void) const
{
	gaussianPolynome dgp((const gaussian &)(*this));
	((polynome &)(dgp)) = ((const polynome &)(*this)).operator*(gaussian::derivate());
	((polynome &)(dgp)) += ((const polynome &)(*this)).derivate();
	return dgp;
}

////////////////////////////////////////////////////////////////////////////////////////////
// - MÃ©thode pour Ã©crire les fonctions de base du polynome.
////////////////////////////////////////////////////////////////////////////////////////////
const string gaussianPolynome::getBaseString(const int & i) const
{
	return monome2string("x",getCenter(),i);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour acÃ©der au polynome.
////////////////////////////////////////////////////////////////////////////////////////////
const polynome & gaussianPolynome::getPolynomeCoefficients(void) const
{
	return (*this);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour accÃ©der aux coefficients du polynome.
////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome::getPolynomeCoefficient(const int & degree) const
{
	return polynome::getData(degree);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour accÃ©der aux coefficients du polynome.
////////////////////////////////////////////////////////////////////////////////////////////
int gaussianPolynome::getPolynomeDegree(void) const
{
	return polynome::getDegree();
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour pour calculer l'intÃ©grale sur R.
////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome::integral(void) const
{
	double value = 0;
	containor<double> integrals;
	gaussian::integrals(getPolynomeDegree() ,integrals);
	for(int i = begin() ; i != end() ; i = next(i)) {
		value += integrals[i] * getPolynomeCoefficient(i);
	}
	return value;
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::multiply(gaussianPolynome gp_a , gaussianPolynome gp_b)
{
	gaussian::multiply(gp_a,gp_b);

	if(gp_a.getCenter() != gp_b.getCenter()) {
		gp_a.changeCenter(getCenter());
		gp_b.changeCenter(getCenter());
	}

	polynome::multiply(gp_a,gp_b);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::multiply(const gaussianPolynome & gaussianPoly)
{
	gaussianPolynome tmp(*this);
	multiply(tmp,gaussianPoly);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::multiply(const gaussianPolynome & gaussianPoly , const double & scalar)
{
	copy(gaussianPoly);
	multiply(scalar);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::multiply(const double & scalar)
{
	gaussian::multiply(scalar);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussianPolynome::operator* (const gaussianPolynome & gp) const
{
	gaussianPolynome tmp;
	tmp.multiply(*this,gp);
	return tmp;
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussianPolynome::operator* (const double & scalar) const
{
	gaussianPolynome tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication unaire de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome & gaussianPolynome::operator*= (const gaussianPolynome & gaussianPoly)
{
	multiply(gaussianPoly);
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour faire la multiplication unaire de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome & gaussianPolynome::operator*= (const double & scalar)
{
	multiply(scalar);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur d'affectation avec une gaussienne polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome & gaussianPolynome::operator =(const gaussianPolynome & gaussianPoly)
{
	copy(gaussianPoly);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur d'affectation avec une gaussienne polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome & gaussianPolynome::operator =(const gaussian & g)
{
	gaussian::copy(g);
	setPolynomeCoefficients(1);
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////
// mÃ©thode pour calculer la primitive.
////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome::primitive(const double & x) const
{
	double value = 0;
	containor<double> primitives;
	gaussian::primitives(x , getPolynomeDegree() , primitives);
	for(int i = begin() ; i != end() ; i = next(i)) {
		value += primitives[i] * getPolynomeCoefficient(i);
	}
	return value;
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour fixer le polynome avec une simple valeur rÃ©elle.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::setPolynomeCoefficients(const double & value)
{
	polynome::setPolynomeCoefficients(value);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour fixer le polynome avec une simple valeur rÃ©elle.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::setPolynomeCoefficients(const polynome & poly)
{
	polynome::setPolynomeCoefficients(poly);
}

////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour fixer le coefficient d'un polynome.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::setPolynomeCoefficient(const int & deg ,const double & value)
{
	polynome::setData(deg,value);
}

/////////////////////////////////////////////////////////////////////////////////
// MÃ©thode qui Ã©crit le polynome gaussien dans un flux.
/////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome::write(ostream & outStream) const
{
	gaussian::write(outStream);
	outStream << ".[ " ;	
	polynome::write(outStream);
	outStream << " ]" ;	
}

////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur externe pour l'Ã©criture.
////////////////////////////////////////////////////////////////////////////////////////////
ostream & operator<<( ostream & outStream , const gaussianPolynome & gp)
{
	gp.write(outStream);
	return outStream;
}
