/* 
* The gaussian library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#define _USE_MATH_DEFINES

#include <containor3D.h>
#include "gaussian.h"
#include "gaussian3D.h"
#include "gaussianPolynome3D.h"
#include <iomanip>
#include <iostream>
#include <math.h>
#include <string>
#include <string4Polynomes.h>
using namespace std;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Les constructeurs.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D::gaussian3D(void)
 :	Center(0,0,0) , Coefficient(1) , Exponent(1)
{
	;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Les constructeurs.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D::gaussian3D(const dpoint<3> & center , const double & coefficient , const double & exponent)
 :	Center(0,0,0) , Coefficient(1) , Exponent(1)
{
	setCenter(center);
	setCoefficient(coefficient);
	setExponent(exponent);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Les constructeurs.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D::gaussian3D(const gaussian3D & g)
 :	Center(0,0,0) , Coefficient(1) , Exponent(1)
{
	//clog << "Log : in gaussian3D::gaussian3D(const gaussian3D & g)" << endl;
	copy(g);
	//clog << "Log : end gaussian3D::gaussian3D(const gaussian3D & g)" << endl;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le Destructeurs.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D::~gaussian3D(void)
{
	;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// La comparaison.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian3D::compare(const gaussian3D & ga , const gaussian3D & gb)
{
	// Les erreurs sur chaque parametre.
	double errorCenter      = dpoint<3>::distance(ga.getCenter() ,gb.getCenter() );
	double errorCoefficient = fabs(ga.getCoefficient() - gb.getCoefficient());
	double errorExponent    = fabs(ga.getExponent()    - gb.getExponent()   );
	double error_max;

	//On va afficher les diffÃ©rences :
	clog << "Log : in double gaussian::compare(const gaussian & ga , const gaussian & gb)" << endl;
	clog << "Log : Centers Error      : " << setprecision(10) <<  errorCenter      << endl;
	clog << "Log : Coefficients Error : " << setprecision(10) <<  errorCoefficient << endl;
	clog << "Log : Exponents Error    : " << setprecision(10) <<  errorExponent    << endl;

	// Ensuite on renvoie l'erreur maximale :
	error_max = max(errorCenter,errorCoefficient);
	error_max = max(error_max,errorExponent);
	
	return error_max;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour claculer le centre de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dpoint<3> gaussian3D:: computeCenter(const gaussian3D & ga , const gaussian3D & gb)
{
	dpoint<3> center;
	center = ga.getCenter() * ga.getExponent() + gb.getCenter() * gb.getExponent();
	center = center / (ga.getExponent() + gb.getExponent());
	return center;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour claculer le coefficient de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian3D::computeCoefficient(const gaussian3D & ga , const gaussian3D & gb)
{
	double coefficient = dpoint<3>::sq_distance(ga.getCenter() , gb.getCenter());
	coefficient = ga.getCoefficient() * gb.getCoefficient() * exp (-(ga.getExponent() * gb.getExponent() * coefficient ) / (ga.getExponent() + gb.getExponent() ) ) ;
	return coefficient;	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour claculer l'exposant de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian3D::computeExponent(const gaussian3D & ga , const gaussian3D & gb)
{
	return ga.getExponent() + gb.getExponent();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// La copie.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::copy(const gaussian3D & g)
{
	//clog << "Log : in void gaussian3D::copy(const gaussian3D & g)" << endl;
	//clog << "Log : set center." << endl;
	setCenter(g.getCenter());
	//clog << "Log : set coefficient." << endl;
	setCoefficient(g.getCoefficient());
	//clog << "Log : set exponent." << endl;
	setExponent(g.getExponent());
	//clog << "Log : end void gaussian3D::copy(const gaussian3D & g)" << endl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// La dÃ©rivation.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussian3D::derivate(int dim) const
{
	assert( dim >= 0);
	assert( dim < 3);
	
	gaussianPolynome3D dgp(*this);
	ipoint<3> deg(0);
	
	dgp.clearPolynome();
	deg[dim] = 1;
	dgp.setPolynomeCoefficient(deg,-2 * getExponent());

	return dgp;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method EVAL
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian3D::eval(const dpoint<3> & x) const
{
	double value;
	value = getCoefficient() * exp( -getExponent() * (x-getCenter()).sq_norme_2() );
	return value;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode get pour le centre.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const dpoint<3> & gaussian3D::getCenter(void) const
{
	//clog << "Log : in const dpoint<3> & gaussian3D::getCenter(void) const" << endl;
	//clog << "Log : center is : " << Center << endl;
	return Center;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode get pour le coefficient.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & gaussian3D::getCoefficient(void) const
{
	//clog << "Log : in const dpoint<3> & gaussian3D::getCoefficient(void) const" << endl;
	//clog << "Log : coefficient is : " << Coefficient << endl;
	return Coefficient;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode get pour l'exposant.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & gaussian3D::getExponent(void) const
{
	//clog << "Log : in const dpoint<3> & gaussian3D::getExponent(void) const" << endl;
	//clog << "Log : exponent is : " << Exponent << endl;
	return Exponent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour claculer l'intÃ©grale sur R d'une gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian3D::integral(void) const
{
	double value = sqrt(M_PI);
	value /= sqrt(getExponent());
	value = pow(value,3);
	value *= getCoefficient();	
	return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode pour claculer l'intÃ©grale sur R d'une gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::integrals(const ipoint<3> & deg_max , containor3D<double> & overlaps) const
{
	assert(deg_max[0] >= 0);
	assert(deg_max[1] >= 0);
	assert(deg_max[2] >= 0);

	int i , j , k , base_deg_max;
	ipoint<3> size(deg_max[0] + 1 , deg_max[1] + 1 , deg_max[2] + 1);
	gaussian base_gaussian;
	containor<double> base_integrals;

	overlaps.setSizes(size);

	base_deg_max = max(max(deg_max[0],deg_max[1]),deg_max[2]);
	base_gaussian.setCenter(0);
	base_gaussian.setExponent(getExponent());
	base_gaussian.setCoefficient(1);
	base_gaussian.integrals( base_deg_max , base_integrals);

	for(i = 0 ; i < size[0] ; i++){
		for(j = 0 ; j < size[1] ; j++){
			for(k = 0 ; k < size[2] ; k++){
				overlaps(i,j,k) = getCoefficient() * base_integrals[i] * base_integrals[j] * base_integrals[k];
			}
		}
	}
} 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode faire la multiplication de deux gaussiennes.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::multiply(const gaussian3D & ga , const gaussian3D & gb)
{
	setCenter(computeCenter(ga,gb));
	setCoefficient(computeCoefficient(ga,gb));
	setExponent(computeExponent(ga,gb));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode faire la multiplication unaire de deux gaussiennes.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::multiply(const gaussian3D & g)
{
	gaussian3D g_tmp;
	g_tmp.multiply(*this,g);
	copy(g_tmp);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode faire la multiplication d'une gaussienne et d'un scalaire.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::multiply(const gaussian3D & g , const double & scalar)
{
	copy(g);
	multiply(scalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode faire la multiplication unaire d'une gaussienne et d'un scalaire.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::multiply(const double & scalar)
{
	double coefficient = scalar * getCoefficient();
	setCoefficient(coefficient);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur pour faire la muiltiplication de deux gaussiennes.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D gaussian3D::operator*(const gaussian3D & g) const
{
	gaussian3D tmp;
	tmp.multiply(*this,g);
	return tmp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur pour faire la muiltiplication d'une gaussienne et d'un scalaire.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D gaussian3D::operator*(const double & scalar) const
{
	gaussian3D tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur externe pour faire la muiltiplication d'une gaussienne et d'un scalaire.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D operator*(const double & scalar , const gaussian3D & g)
{
	return g*scalar;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur pour faire la muiltiplication de deux gaussiennes.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D & gaussian3D::operator*=(const gaussian3D & g) 
{
	multiply(g);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur unaire pour faire la muiltiplication d'une gaussienne et d'un scalaire.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian3D & gaussian3D::operator*=(const double & scalar) 
{
	multiply(scalar);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode SET pour le centre de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::setCenter(const dpoint<3> & center)
{
	Center = center;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode SET pour le centre de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::setCenter(const double & center_x , const double & center_y , const double & center_z)
{
	Center.setDatas(center_x,center_y,center_z);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode SET pour le coefficient de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::setCoefficient(const double & coefficient)
{
	Coefficient = coefficient;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode SET pour l'Exposant de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::setExponent(const double & exponent)
{
	assert(exponent > 0);
	Exponent = exponent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MÃ©thode WRITE de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian3D::write(ostream & outStream) const
{
	if(getCoefficient() != 1) {
		outStream << getCoefficient();
		outStream << " * ";
	}
	
	outStream << "exp( -";
	
	if(getExponent() != 1){
		outStream << getExponent();
		outStream << " * ";
	}
	
	outStream << "(";
	
	outStream << monome2string("x",getCenter()[0],2);
	outStream << " + ";
	outStream << monome2string("y",getCenter()[1],2);
	outStream << " + ";
	outStream << monome2string("z",getCenter()[2],2);
	
	outStream << "))";
	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÃ©rateur externe pour Ã©crire la gaussienne dans un flux.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ostream & operator << (ostream & outStream , const gaussian3D & g)
{
	g.write(outStream);
	return outStream;
}

