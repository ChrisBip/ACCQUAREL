/* 
* The martix library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "vector.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vector::vector(void)
: Coefficients(NULL) , NbrOfRows(0) 
{
	;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor with size spÃ©cification.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vector::vector(int nbrOfRows)
: Coefficients(NULL) , NbrOfRows(0) 
{
	assert(nbrOfRows >= 0);
	
	if(nbrOfRows > 0)
		setNbrOfRows(nbrOfRows);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vector::vector(const vector & v)
: Coefficients(NULL) , NbrOfRows(0) 
{
	copy(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vector::~vector(void)
{
	clear();
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The allocation Method.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::allocStorage(const int & nbrOfRows)
{
	assert(NbrOfRows == 0);
	assert(Coefficients == NULL);
	
	assert(nbrOfRows > 0);
	
	Coefficients = new double [nbrOfRows];
	NbrOfRows = nbrOfRows;
}	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The CLEAR Method
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::clear(void)
{
	if(empty()) {
		return;
	} else {
		freeStorage();
	}
}	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The COPY Method
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::copy(const vector & v)
{
	
	if(v.empty()) {
		clear();
		return;
	}
	
	setNbrOfRows(v.getNbrOfRows());
	
	for(int i=0 ; i < getNbrOfRows() ; i++) {
		setCoefficient(i,v.getCoefficient(i));
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The EMPTY Method
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool vector::empty(void) const
{
	if(getNbrOfRows() == 0) {
		return true;
	} else {
		return false;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The desallocation Method.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::freeStorage(void)
{
	if(NbrOfRows == 0) 
		return;
	
	delete [] Coefficients;
	Coefficients = NULL;
	NbrOfRows = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The GET Method for a coefficient of the vector.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & vector::getCoefficient(const int & row) const
{
	assert(row >= 0);
	assert(row < getNbrOfRows() );
	
	return Coefficients[row];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The GET Method for a coefficient of the vector.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & vector::getCoefficient(const int & row)
{
	assert(row >= 0);
	assert(row < getNbrOfRows() );
	
	return Coefficients[row];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The GET Method for the number of rows.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int vector::getNbrOfRows(void) const
{
	return NbrOfRows;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The GET Method for a coefficient of the vector.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & vector::operator[](const int & row) const
{
	assert(row >= 0);
	assert(row < getNbrOfRows() );
	
	return getCoefficient(row);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The GET Method for a coefficient of the vector.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & vector::operator[](const int & row)
{
	assert(row >= 0);
	assert(row < getNbrOfRows() );
	
	return getCoefficient(row);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The SET Method for the nuber of rows.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::setCoefficient(const int & row , const double & value)
{
	assert(row >= 0);
	assert(row < getNbrOfRows() );
	
	Coefficients[row] = value;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The SET Method for the nuber of rows.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::setNbrOfRows(const int & nbrOfRows)
{
	assert(nbrOfRows > 0);
	
	if(nbrOfRows == getNbrOfRows() ) {
		return;
	}
	
	if(!empty()) {
		clear();
	}
	
	allocStorage(nbrOfRows);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The SET Method for the size.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::setVectorSize(int size)
{
	assert(size > 0);
	setNbrOfRows(size);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The Method to compute the norm of a vector
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double vector::Norm(void) const
{ double norm = 0.0;
  int i;
  for (i=0;i<getNbrOfRows();i++){
     norm += Coefficients[i] * Coefficients[i];
  }
  norm = sqrt(norm);
  return (norm);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that computes the scalar product of two vectors
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double vectorScalarProduct(const vector & u,const vector & v) 
{  int i;
   double d = 0.0;
   
   assert (u.getNbrOfRows() == v.getNbrOfRows());
   
   for (i=0;i<u.getNbrOfRows();i++){
      d += u[i] * v[i];
   }
   
   return d;
      
   }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that computes the L2 scalar product of two vectors with respect to an overlap matrix
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double L2vectorScalarProduct(const vector & u,const vector & v, const matrixSymetric & Moverlap) 
{ int mu, nu;
  double ps = 0.0;
  
  assert(u.getNbrOfRows()==v.getNbrOfRows());
  
     for (mu=0;mu<Moverlap.getNbrOfColumns();mu++){
	    for (nu=0;nu<Moverlap.getNbrOfColumns();nu++){
		   ps += u[mu] * v[nu] * Moverlap(mu,nu);
		}// end of nu loop
	 }// end of mu loop
 
return ps;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that computes the L2 norm with respect to an overlap matrix
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double L2vectorNorm(const vector & u, const matrixSymetric & Moverlap) 
{  double norm;
  
   norm = sqrt(L2vectorScalarProduct(u,u,Moverlap));
  
   return norm;  
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that computes the product of a matrix and a vector
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const vector ProductMatrixVector(const matrixFull & A, const vector & v)
{  int i, j;
   assert (A.getNbrOfColumns() == v.getNbrOfRows());
   
   vector result(v.getNbrOfRows());
   
   for (i=0;i<v.getNbrOfRows();i++){
      result[i] = 0;
	  for (j=0;j<A.getNbrOfColumns();j++){
	     result[i] += A(i,j) * v[j];
	  }
   }	 	 

   return result; 

} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that solves the linear equation AX=LUX=b
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const void LUsolver(vector & x,const vector & b, const matrixFull & A) 
{  int i, ii=0, ip, j;
   double sum;
   int *indx;
   double d;
   
   assert (A.getNbrOfRows() == A.getNbrOfColumns());
   assert(b.getNbrOfRows() == A.getNbrOfRows());
   
   cout << "Solving the linear equation with the LU decomposition." << endl;
   
   indx = new int [b.getNbrOfRows()];
   
   matrixFull lu(A.getNbrOfRows(),A.getNbrOfRows());
      
   A.LUdecomposition(lu,indx,d);
   
   for (i=0;i<b.getNbrOfRows();i++){
      x[i] = b[i];
   }
   
   for (i=0;i<b.getNbrOfRows();i++){
      ip = indx[i];
	  sum = x[ip];
	  x[ip] = x[i];
	  if (ii!=0){
	     for (j=ii-1;j<i;j++){
		    sum -= lu(i,j) * x[j];
		 }// end of j loop
	  }// end if
	  else if (sum!=0.0){
	     ii = i+1;
	  }// end else if	 
		 x[i] = sum;
   }// end of i loop
   for (i=b.getNbrOfRows()-1;i>=0;i--){
      sum = x[i];
	  for (j=i+1;j<b.getNbrOfRows();j++){
	     sum -= lu(i,j) * x[j];
	  }// end of j loop
	  x[i] = sum / lu(i,i);
   }// end of i loop
   
   cout << "The linear equation is solved." << endl;
   
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The friend method that computes the inverse of a matrix A from its LU decomposition
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const void LUinverse( matrixFull & inv, const matrixFull & A)
{  assert (A.getNbrOfRows() == A.getNbrOfColumns());
   assert(inv.getNbrOfRows() == A.getNbrOfRows());
   assert(inv.getNbrOfColumns() == A.getNbrOfRows());
   
   vector col(A.getNbrOfRows());
   vector x(A.getNbrOfRows());
   double d;
   int i, j;
   
   cout <<"Computing the inverse of the matrix with its LU decomposition" << endl;
   
   //A.LUdecomposition(lu,indx,&d);
   for (j=0;j<A.getNbrOfRows();j++){
      for (i=0;i<A.getNbrOfRows();i++){
	     col[i] = 0.0;
	  }// end of i loop
	  col[j] = 1.0;
	  LUsolver(x,col,A);
	  for (i=0;i<A.getNbrOfRows();i++){
	     inv(i,j) = x[i];
	  }// end of i loop
   }// end of j loop
   
   cout <<"The inverted matrix is computed" << endl;

} 


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The redefinition of the operator =
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vector vector::operator = (const vector & v)
{ if (this != & v){
     //delete Coefficients;
	 freeStorage();
     //Coefficients = new double [getNbrOfRows()=v.getNbrOfRows()];
	 allocStorage(v.getNbrOfRows());
     int i;
     for (i=0;i<v.getNbrOfRows();i++){
        Coefficients[i] = v[i];
	 }
  } 
return *this;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The WRITE Method
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void vector::writeHuman(ostream & outStream , int width , int precision) const
{
	int row , nbrOfRows;

	nbrOfRows = getNbrOfRows();
	for(row=0 ; row < nbrOfRows ; row++) {
		if(row > 0) {
			outStream << " , " ;
		}
		outStream << setw(width) << setprecision(precision) << getCoefficient(row);	
	}
}