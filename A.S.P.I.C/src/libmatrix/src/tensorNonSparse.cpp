/* 
* The martix library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "tensorNonSparse.h"
#include <cstdlib>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Default constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tensorNonSparse::tensorNonSparse(void)
	: tensor() , Storage(NULL) , StorageSize(0)
{
		;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tensorNonSparse::~tensorNonSparse(void)
{
		clear();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method for the allocation of the storage memory.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::allocStorage(const int & storageSize)
{
	if(getStorageSize() > 0) {
		freeStorage();
	}
	
	if(storageSize == 0) {
		return;
	}
	
	Storage = new double [storageSize];
	StorageSize = storageSize;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The CLEAR Method.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::clear(void)
{
	tensor::clear();
	freeStorage();
}	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The COPY Method.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::copy(const tensorNonSparse & t)
{

	// The following exception may occur :
	//
	// one trys to copy a tensor FULL in a SYMETRIC one.
	// as this point this may not be very smart as the storage
	// and access method for those types of objects are very different
	//
	// to ensure that shall not appen, we olny copy tensor from the same
	// types.
	if(t.getTensorType() != getTensorType()) {
		cerr << "Error : in void tensorNonSparse::copy(const tensorNonSparse & t)" << endl;
		cerr << "Error : unable to copy a " << t.getTensorType() << " tensor in a " << getTensorType() << " tensor." << endl;
		cerr << "Error : assertion failed." << endl;
		exit(1);
	}

	// if the argument is empty we just clear the
	// object inwhich the tensor t shall be copied.
	if(t.empty()) {
		clear();
		return;
	}
	
	tensor::copy(t);
	setStorageSize(t.getStorageSize());
	
	for(int i=0 ; i < getStorageSize() ; i++) {
		setStorage(i , t.getStorage(i));
	}


}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method for the desallocation of the storage memory.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::freeStorage(void)
{
	if(getStorageSize() == 0) {
		return;
	}
		
	delete [] Storage;
	Storage = NULL;
	StorageSize = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & tensorNonSparse::getCoefficient(const int & row , const int & column , const int & width , const int & height) const
{
	assert(column >= 0);
	assert(column < getNbrOfColumns());

	assert(height >= 0);
	assert(height < getNbrOfHeights());

	assert(row >= 0);
	assert(row < getNbrOfRows());

	assert(width >= 0);
	assert(width < getNbrOfWidths());

	return getStorage(hash(row , column , width , height));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & tensorNonSparse::getCoefficient(const int & row , const int & column , const int & width , const int & height)
{
	assert(column >= 0);
	assert(column < getNbrOfColumns());

	assert(height >= 0);
	assert(height < getNbrOfHeights());

	assert(row >= 0);
	assert(row < getNbrOfRows());

	assert(width >= 0);
	assert(width < getNbrOfWidths());

	return getStorage(hash(row , column , width , height));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & tensorNonSparse::getStorage(const int & item) const
{
	assert(item >= 0);
	assert(item < getStorageSize());
	
	return Storage[item];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & tensorNonSparse::getStorage(const int & item)
{
	assert(item >= 0);
	assert(item < getStorageSize());
	
	return Storage[item];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the size of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const int & tensorNonSparse::getStorageSize(void) const
{	
	return StorageSize;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & tensorNonSparse::operator[] (const int & item) const
{
	assert(item >= 0);
	assert(item < getStorageSize());
	
	return getStorage(item);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & tensorNonSparse::operator[] (const int & item)
{
	assert(item >= 0);
	assert(item < getStorageSize());
	
	return getStorage(item);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the tensor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & tensorNonSparse::operator()(const int & row , const int & column , const int & width , const int & height) const
{
	assert(column >= 0);
	assert(column < getNbrOfColumns());

	assert(height >= 0);
	assert(height < getNbrOfHeights());

	assert(row >= 0);
	assert(row < getNbrOfRows());

	assert(width >= 0);
	assert(width < getNbrOfWidths());

	return getCoefficient(row , column , width , height);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method GET for the item element of the tensor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & tensorNonSparse::operator()(const int & row , const int & column , const int & width , const int & height)
{
	assert(column >= 0);
	assert(column < getNbrOfColumns());

	assert(height >= 0);
	assert(height < getNbrOfHeights());

	assert(row >= 0);
	assert(row < getNbrOfRows());

	assert(width >= 0);
	assert(width < getNbrOfWidths());

	return getCoefficient(row , column , width , height);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method SET for the element row x column of the tensor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::setAllCoefficients(const double & value)
{
	int i , storageSize;
	
	storageSize = getStorageSize();
	
	for(i=0 ; i < storageSize ; i++) {
		setStorage(i,value);
	}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method SET for the element row x column of the tensor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::setCoefficient(const int & row , const int & column , const int & width , const int & height , const double & value)
{
	assert(column >= 0);
	assert(column < getNbrOfColumns());
	
	assert(height >= 0);
	assert(height < getNbrOfHeights());
		
	assert(row >= 0);
	assert(row < getNbrOfRows());
	
	assert(width >= 0);
	assert(width < getNbrOfWidths());
		
	return setStorage(hash(row , column , width , height) , value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method SET for the tensor size.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::setTensorSize(const int & nbrOfRows , const int & nbrOfColumns ,  const int & nbrOfWidths , const int & nbrOfHeights)
{
	setNbrOfColumns(nbrOfColumns);
	setNbrOfHeights(nbrOfHeights);
	setNbrOfRows(nbrOfRows);
	setNbrOfWidths(nbrOfWidths);
	
	setStorageSize(computeStorageSize());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method SET for the item element of the storage array.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::setStorage(const int & item ,const  double & value)
{
	assert(item >= 0);
	assert(item < getStorageSize());
	
	Storage[item] = value;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method SET for the storage size.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void tensorNonSparse::setStorageSize(const int & storageSize)
{
	assert(storageSize > 0);
	
	if(storageSize == getStorageSize() ) {
		return;
	}
	
	if(getStorageSize() > 0) {
		freeStorage();
	}

	allocStorage(storageSize);
}





