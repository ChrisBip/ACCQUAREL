/* 
 * The complex library of the A.S.P.I.C. 
 * Written and directed by François Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  François Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * CERMICS, ENPC, hereby disclaims all copyright interest in
 * the library `complex' (a library of complex for A.S.P.I.C.) written
 * by François Lodier.
 */
#include "complex.h"
#include <assert.h>
#include <math.h> 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur par défaut.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex::complex(void)
: Real(0) , Im(0)
{
	;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur avec un nombre réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex::complex(double real)
: Real(real) , Im(0)
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur avec la partie réelle et imaginaire.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex::complex(double real , double im)
: Real(real) , Im(im)
{
	;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur de copie.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex::complex(const complex & c)
: Real(0) , Im(0)
{
	copy(c);
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le destructeur.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex::~complex(void)
{
	;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour calculer le conjugué.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::conjugate(void) const
{
	complex result;
	result.real() = real();
	result.im() = -im();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour copier un nombre complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void complex::copy(const complex & c)
{
	real() = c.real();
	im() = c.im();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode constante pour accéder à la partie imaginaire pure.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & complex::im(void) const
{
	return Im;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour accéder à la partie imaginaire pure.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & complex::im(void)
{
	return Im;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour savoir la valeur de l'objet est un nombre imaginaire pur.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::is_pure_im(void) const
{
	if(real() == 0) return true;
	else return false;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour savoir la valeur de l'objet est un nombre réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::is_real(void) const
{
	if(im()==0) return true;	
	else return false;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour calculer le module.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double complex::module(void) const
{
	return sqrt(sq_module());
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiplication de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator *(const complex & c) const
{
	complex result;
	result.real() = real() * c.real() - im() * c.im();
	result.im() = real() * c.im() + im() * c.real();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiplication unaire de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator *=(const complex & c) 
{
	copy((*this) * c);
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiplication d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator *(const double & r) const
{
	complex result;
	result.real() = r*real();
	result.im() = r* im();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiplication unaire d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator *=(const double & r) 
{
	real() *= r;
	im() *= r;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiplication d'un réel et d'un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex operator*(const double & r , const complex & c)
{
	return c*r;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Addition de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator +(const complex & c) const
{
	complex result;
	result.real() = real() + c.real();
	result.im() = im() + c.im();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Addition unaire de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator +=(const complex & c) 
{
	real() += c.real();
	im() += c.im();
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Addition d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator +(const double & r) const
{
	complex result;
	result.real() = real() +r;
	result.im() = im();
	return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Addition unaire d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator +=(const double & r) 
{
	real() += r;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Addition d'un réel et d'un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex operator+(const double & r , const complex & c)
{
	return c+r;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Soustraction de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator -(const complex & c) const
{
	complex result;
	result.real() = real() - c.real();
	result.im() = im() - c.im();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sosutraction unaire de deux complexes.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator -=(const complex & c)
{
	real() -=c.real();
	im() -= c.im();
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Soustraction d'un complexe et d'un réel
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator -(const double & r) const
{
	complex result;
	result.real() = real() -r;
	result.im() = im();
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Soustraction unaire d'un complexe et d'un réel
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator -=(const double & r)
{
	real() -=r;
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Soustraction d'un réel et d'un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex operator-(const double & r , const complex & c)
{
	return c-r;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Division de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator /(const complex & c) const
{
	assert(c.module() != 0);

	complex result = *this * c.conjugate();
	result /= c.sq_module();
	return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Division unaire de deux complexes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator /=(const complex & c) 
{
	copy( (*this) / c );
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Division d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex complex::operator /(const double & r) const
{
	assert(r!=0);

	complex result;
	result.real() = real() / r;
	result.im() = im() / r;
	return result;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Division unaire d'un complexe et d'un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator /=(const double & r) 
{
	assert(r!=0);

	real() /=r;
	im() /= r;
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Division d'un réel et d'un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex operator/(const double & r , const complex & c)
{
	complex tmp(r);
	return tmp /c;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Affectation avec un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator=(const double & r)
{
	real() = r;
	im() = 0;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Affectation avec un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
complex & complex::operator=(const complex & c)
{
	copy(c);
	return *this;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Comparaison avec un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::operator ==(const double & r) const
{
	if(is_real() && real() == r) return true;
	else return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Comparaison avec un réel.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::operator !=(const double & r) const
{
	return !(this->operator ==(r));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Comparaison avec un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::operator ==(const complex & c) const
{
	if(real() == c.real() && im() == c.im()) return true;
	else return false;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Comparaison avec un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool complex::operator !=(const complex & c) const
{
	return !(this->operator ==(c));
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode constante pour accéder à la partie réelle.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & complex::real(void) const
{
	return Real;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour accéder à la partie réelle.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double & complex::real(void)
{
	return Real;
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour calculer le module au carré.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double complex::sq_module(void) const
{
	return ((*this) * (*this).conjugate()).real();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Méthode pour afficher un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void complex::write(ostream & out) const
{
	double r , i ;

	r = real();
	i = im(); 
	
	if(i==0) {
		out << r;
		return;
	} 	if(r!= 0) {
		out << "( ";
		out << r ;
	}
	
	if(im() < 0) {
		out << "- " ;
		i = -i;
	}
		
	out << "i";

	if(i != 1) {
		out << "*" << i ;
	}

	if(r!= 0) {
		out << " )";
	}
} 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Opérateur pour afficher un complexe.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ostream & operator<<(ostream & out , const complex & c) { 	c.write(out); 	return out; } 
